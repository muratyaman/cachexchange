const amqp = require('amqp-connection-manager');
const { amqpConfig, amqpSettings } = require('./constants');

function makeAmqpClient({
  url                        = amqpConfig.url,
  heartbeatIntervalInSeconds = amqpConfig.heartbeatIntervalInSeconds,
  reconnectTimeInSeconds     = amqpConfig.reconnectTimeInSeconds,
  exchangeName               = amqpConfig.exchangeName,
  prefetchMessageCount       = amqpConfig.prefetchMessageCount,
  onMessage                  = async (_message) => {},
  onSetup                    = async ({ queueName, exchangeName }) => {},
  onError                    = (err) => { throw err; },
}) {

  const brokers = [ url ];
  const options = {
    heartbeatIntervalInSeconds,
    reconnectTimeInSeconds,
  };
  const _connection = amqp.connect(brokers, options);

  _connection.on('error', (err) => {
    onError(err);
  });

  const _channelWrapper = _connection.createChannel({
    json: true,
    publishTimeout: amqpSettings.publishTimeout,
    setup: async (channel) => {
      await channel.assertExchange(exchangeName, amqpSettings.exchangeType, amqpSettings.exchangeOptions);
      const queueObj = await channel.assertQueue(amqpSettings.queueNameAutoGenerated, amqpSettings.queueOptions);
      const queueName = queueObj.queue;
      await channel.bindQueue(queueName, exchangeName, amqpSettings.bindToAllRoutes);
      await channel.prefetch(prefetchMessageCount);
      await channel.consume(queueName, onMessage);
      await onSetup({ queueName, exchangeName });
    },
  });

  _channelWrapper.on('error', (err) => {
    onError(err);
  });

  async function publish(message) {
    return _channelWrapper.publish(exchangeName, amqpSettings.publishToAllQueues, message);
  }

  return {
    _connection,
    _channelWrapper,
    publish,
  };
}

module.exports = {
  makeAmqpClient,
};
